方法一：
    解决回溯问题，主要是解决决策树遍历的过程；
    考虑的3个问题：
        （1）路径：已经做出的选择；
        （2）选择列表：当前可以做的选择；
        （3）结束条件：到达决策树底层，无法在进行选择；


代码框架：
    result= []
    def backtrack(路径、选择列表)：
        if 满足结束条件：
            result.add(路径)
            return
        
        for 选择 in 选择列表
            做选择
                将该选择从选择列表中删除；
                路径.add(选择)；
            backtrack（路径、选择列表）
            撤销选择；
                路径.remove(xuanze );
                将该选择从选择列表中添加进去；
        
//全排列的问题

//track中主要用于存储路径；
//nums主要是数组；
路径：记录在track中；
选择列表：在num中，不在track中的；
结束条件：num中的元素全部在track中出现；

void Core( vector<vector<int>>& res, vector<int>& nums, vector<int>& track){

    if(track.size() == nums.size()){
        res.push_back(track);
        return;
    }

    for( int i =0 ;i < nums.size() ;i++){
        if( track.continues(nums[i])){
            continues;
        }

        track.add(nums[i]);

        Core(res,nums,track);

        track.remove(nums[i]);
    }
}



vector<vector<int>> permute(vector<int>& nums) {

   vector<vector<int>> res; //全局变量存储答案；
   vector<int> track ;//存储路径；

    Core( res, nums, track);
    return res;
}

//N皇后问题：不能同行，同列，以及斜对角线；


vector<vector<string>> res;

vector<vector<string>> sloveQueen( int n){
    //'.'表示空，'Q'表示皇后，初始化空棋盘；
    vector<vector<string>> board(n,vector<string>(n,'.'));
    backtrack(board,0);
    return res;
}

路径：board中小于row的那些行成功放置了皇后；
选择列表：第row行中的每一列放置Q的位置；
结束：row超过了board中的最后一行；

void backtrack(vector<vector<string>>& board, int row){

    if(row == board.size()){
        res.push_back(board);
        return;
    }

    //遍历选择列表；
    for(int i =0 ; i< board[row].size() ; i++ ){
        if( !isVlid(board,row,i)){
            continue;
        }
        //做选择；
        board[row][i] = 'Q';
        //进入到下一个环节；
        backtrack(board,row+1);
        //撤销选择；
        board[row][i] = '.';
    }

}


bool isVlid( vector<vector<string>>& board, int row , int col ){
    int n = board.size();
    for(int i =0 ; i< n ; i++){
        if( board[i][ol] == 'Q){
            return false;
        }
    }
    //检查右上方对角线；
    for(int i = row-1 ,j= col+1 ; i>=0 && j < n; i--,j++){
        if( board[i][j] == 'Q){
            return false;
        }
    }

    //检查左上方对角线；
    for(int i = row-1,j=col-1 ; i>=0 && j>=0 ; j--,i--){
        if(board[i][j] == 'Q){
            return false;
        }
    }

    return true;
}