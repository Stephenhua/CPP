#include <iostream>
#include <vector>
#include <cmath>
#include <map>
#include <algorithm>
#include <string.h>
using namespace std;

/*
面试题 17.16. 按摩师
一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。

注意：本题相对原题稍作改动

 

示例 1：

输入： [1,2,3,1]
输出： 4
解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。
示例 2：

输入： [2,7,9,3,1]
输出： 12
解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。
示例 3：

输入： [2,1,4,5,3,1,1,3]
输出： 12
解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。

*/

//动态规划二维数组；
/*
第 1 步：设计状态
「状态」这个词可以理解为「记录了求解问题到了哪一个阶段」。

由于当前这一天有按摩师有两种选择：（1）接预约；（2）不接预约。但根据题意，今天是否接预约，是受到昨天影响的。为了消除这种影响，我们在状态数组要设置这个维度。

dp[i][0] 表示：区间 [0，i] 里接受预约请求，并且下标为 i 的这一天不接受预约的最大时长；
dp[i][1] 表示：区间 [0，i] 里接受预约请求，并且下标为 i 的这一天接受预约的最大时长。

说明：这个定义是有前缀性质的，即当前的状态值考虑了（或者说综合了）之前的相关的状态值，第 2 维保存了当前最优值的决策，这种通过增加维度，消除后效性的操作在「动态规划」问题里是非常常见的。

无后效性的理解：1、后面的决策不会影响到前面的决策； 2、之前的状态怎么来的并不重要。

一般的情况是，只要有约束，就可以增加一个维度消除这种约束带来的影响，再具体一点说，就是把「状态」定义得清楚、准确，「状态转移方程」就容易得到了。「力扣」的几道股票问题基本都是这个思路，而且设置状态的思想和这道题是完全一致的。

第 2 步：状态转移方程
「状态转移方程」可以理解为「不同阶段之间的联系」。

今天只和昨天的状态相关，依然是分类讨论：

今天不接受预约：或者是昨天不接受预约，或者是昨天接受了预约，取二者最大值，即：dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])；
今天接受预约：只需要从昨天不接受预约转移而来，加上今天的时常，即：dp[i][1] = dp[i - 1][0] + nums[i]。
第 3 步：考虑初始化
从第 2 天开始，每天的状态值只与前一天有关，因此第 1 天就只好老老实实算了。好在不难判断：dp[0][0] = 0 与 dp[0][1] = nums[0]；

这里有一种技巧，可以把状态数组多设置一行，这样可以减少对第 1 天的初始化，这样的代码把第 1 天的情况考虑了进去，但编码的时候要注意状态数组下标的设置， 请见题解最后的「参考代码 3」。

第 4 步：考虑输出
由于状态值的定义是前缀性质的，因此最后一天的状态值就考虑了之前所有的天数的情况。按摩师最后一天可以接受预约，也可以不接受预约，取二者最大值。

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/the-masseuse-lcci/solution/dong-tai-gui-hua-by-liweiwei1419-8/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

*/
class Solution {
public:
    int massage(vector<int>& nums) {
        int size = nums.size();

        if( size == 0){
            return 0 ;
        }
        if( size == 1 ){
            return nums[0];
        }

        int dp[size][2];

        dp[0][0] = 0 ;
        dp[0][1] = nums[0];

        for( int i = 1 ;i < size ;i++){
            dp[i][0] = max( dp[i-1][0],dp[i-1][1]);
            dp[i][1] = dp[i-1][0] = nums[i];
        }

        return max( dp[size][0],dp[size][1]);
    }
};


//方法二：设计一维状态变量；

/*
第 1 步：定义状态
dp[i]：区间 [0，i] 里接受预约请求的最大时长。

第 2 步：状态转移方程
这个时候因为不限定下标为 i 这一天是否接受预约，因此需要分类讨论：

接受预约，那么昨天就一定休息，由于状态 dp[i - 1] 的定义涵盖了下标为 i - 1 这一天接收预约的情况，状态只能从下标为 i - 2 的状态转移而来：dp[i - 2] + nums[i]；
不接受预约，那么昨天可以休息，也可以不休息，状态从下标为 i - 1 的状态转移而来：dp[i - 1]；
二者取最大值，因此状态转移方程为 dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])。

第 3 步：思考初始化
看状态转移方程，下标最小到 i - 2，因此初始化的时候要把 dp[0] 和 dp[1] 算出来，从 dp[2] 开始计算。

dp[0]：只有 1 天的时候，必须接受预约，因此 dp[0] = nums[0]；
dp[1]：头 2 天的时候，由于不能同时接受预约，因此最优值是这两天接受预约时长的最大值 dp[1] = max(nums[0], nums[1])；
第 4 步：思考输出
由于定义的状态有前缀性质，并且对于下标为 i 的这一天也考虑了接受预约与不接受预约的情况，因此输出就是最后一天的状态值。

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/the-masseuse-lcci/solution/dong-tai-gui-hua-by-liweiwei1419-8/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*/

class Solution {
public:
    int massage(vector<int>& nums) {
        int  size = nums.size();
        if( size == 0 ){
            return 0 ;
        }

        if(size == 1){
            return nums[0];
        }

        int dp[size];
        dp[0] = nums[0];
        dp[1] = max(nums[0],nums[1]);

        for( int i =2 ; i <size ;i++){

            dp[i] = max( dp[i-1],dp[i-2]+nums[i]);
        }

        return dp[size-1];
    }

}